# CarND-Path-Planning-Project
Self-Driving Car Engineer Nanodegree Program

### Goals
In this project your goal is to safely navigate around a virtual highway with other traffic that is driving +-10 MPH of the 50 MPH speed limit. You will be provided the car's localization and sensor fusion data, there is also a sparse map list of waypoints around the highway. The car should try to go as close as possible to the 50 MPH speed limit, which means passing slower traffic when possible, note that other cars will try to change lanes too. The car should avoid hitting other cars at all cost as well as driving inside of the marked road lanes at all times, unless going from one lane to another. The car should be able to make one complete loop around the 6946m highway. Since the car is trying to go 50 MPH, it should take a little over 5 minutes to complete 1 loop. Also the car should not experience total acceleration over 10 m/s^2 and jerk that is greater than 10 m/s^3.

### Behavior Planning

The behavior planner was implemented using a Vehicle class (vehicle.h and vehicle.cpp).  A vehicle object was instantiated for the ego vehicle (main.cpp, lines 179-242) and each other vehicle on the same side of the road as the ego vehicle (main.cpp, lines 139-177), such that each vehicle objected was initialized with the correct position, velocity, and acceleration.  Vehicles other than the ego vehicle were assumed to have 0 acceleration.

The behavior planner was implemented using a finite state machine.  The finite state machine consisted of the following states: keep lane (KL), prepare lane change right/left (PLCR/PLCL), and lane change (LCR/LCL) (vehicle.cpp, Vehicle::successor_states).  The ego vehicle could transition from KL either back to KL or to PLCL/PLCR.  Transitions from PLCL to KL, PLCL, or LCL were possible (likewise for PLCR and LCR).  Additionally, transitions from LCL back to LCL and to KL were possible (likewise for LCR).  The ego vehicle could not transition out of LCL/LCR until it had finished the lane change as determined by the distance in the frenet d coordinate of the ego vehicle from the center of the lane the ego vehicle was changing into (vehicle.cpp, lines 164-187).  Additionally, the ego vehicle could not transition from PLCL/PLCR to LCL/LCR until the speed of the ego vehicle matched the speed of the vehicle in front of the ego vehicle in the next lane, if possible (vehicle.cpp, lines 204-292).

When choosing the next state for the ego vehicle, a trajectory consisting of a final position, velocity, and acceleration is generated for each potential state (vehicle.cpp, Vehicle::choose_next_state).  The new trajectory is generated such that the vehicle will travel near the speed limit (47.5 miles per hour) unless prevented to do so by the vehicle in front of it (vehicle.cpp, Vehicle::get_kinematics).  For PLCL/PLCR trajectories, the ego vehicle will attempt to match the speed of the vehicle in front of it in the next lane if possible (vehicle.cpp, Vehicle::prep_lane_change_trajectory).  If another vehicle is blocking the ego vehicle from performing a lane change, no cost will be calculated for the PLCL/PLCR state (vehicle.cpp, lines 528-546).  For LCL/LCR trajectories, if another vehicle is attempting to make a lane change at the same time as the ego vehicle, a cost will not be calculated for the trajectory (vehicle.cpp, lines 764-778).  Alternatively, if a vehicle in the intended lane is blocking a lane change, a cost will not be calculated for the LCL/LCR trajectory (vehicle.cpp, lines 780-792).  Also, if there is a vehicle behind the ego vehicle in the intended lane that is traveling faster than the ego vehicle, a cost will not be calculated for the LCL/LCR trajectory (vehicle.cpp, lines 795-808).

### Cost Functions

The cost for each trajectory is calculated as a weighted sum of two cost functions, a cost function that penalizes the ego vehicle for being outside the middle lane (weight: 0.15) (cost.cpp, goal_lane_cost, lines 17-36) and a cost function that penalizes the ego vehicle for traveling at a slower speed than the target speed (47.5 mph) (weight: 0.85) (cost.cpp, inefficiency_cost, lines 38-73).

### Trajectory Generation

Trajectories for the ego vehicle were generated using a spline.  A spline was fit to five points on each iteration.  The first two points were taken from the ego vehicle's previous path (main.cpp, lines 302-315).  If a previous path was not available, and only the ego vehicle's present location was available, point was projected back using the ego vehicle's current velocity and orientation (main.cpp, lines 288-295).  The next three points were projected out 30m, 60m, and 90 meters out from the ego vehicle's current position in the frenet s coordinate (main.cpp, lines 321-340).  The d coordinate of these last three points, was chosen to match the center of the lane chosen by the behavior planner. To avoid the problem of generating a trajectory where a given global x coordinate was associated with multiple global y coordinates, spline calculations were performed in the ego vehicle's reference frame (main.cpp, lines 345-358 and lines 399-407).  On each iteration, a trajectory consisting of 50 points was generated.  To generate these points, points from the spline were appended to the ego vehicle's previous path (main.cpp, lines 372-376).  New points were generated such that the vehicle would have a velocity as chosen by the behavior planner (main.cpp, lines 381-397).  Additionally, the trajectory was generated with a constant acceleration on each iteration.
